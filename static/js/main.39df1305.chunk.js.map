{"version":3,"sources":["components/utils.js","components/FormatToolbar.js","components/TextEditor.js","App.js","serviceWorker.js","index.js"],"names":["Button","styled","_templateObject","props","reversed","active","Icon","_ref","className","rest","Object","objectWithoutProperties","react_default","a","createElement","assign","concat","_templateObject2","Menu","_templateObject3","Image","_templateObject4","_templateObject5","selected","FormatToolbar","children","DEFAULT_NODE","isTabHotkey","isKeyHotkey","isShiftTabHotkey","existingValue","JSON","parse","localStorage","getItem","initialValue","Value","fromJSON","initialValueFromJSON","schema","document","last","type","normalize","editor","code","node","child","paragraph","Block","create","insertNodeByKey","key","nodes","size","blocks","image","isVoid","insertImage","src","target","select","insertBlock","data","TextEditor","state","value","saveButton","blockLimit","fileSaved","ref","_this","hasBlock","some","onChange","_ref2","countBlocks","setState","onClickSave","event","preventDefault","assertThisInitialized","content","stringify","toJSON","setItem","window","setTimeout","onClickCancel","onChangeBlockLimit","getBlocks","filter","block","text","onKeyDown","next","first","parent","getParent","previousSibling","getPreviousSibling","getDepth","flag","map","nextSibling","getNextSibling","setBlocks","wrapBlock","firstBlockDepth","hasChildren","blok","depth","unwrapBlock","renderNode","attributes","isFocused","get","onClickImage","prompt","command","onClickImageUploadButton","getElementById","click","uploadImage","file","files","reader","FileReader","_file$type$split","split","slicedToArray","getEventRange","addEventListener","result","readAsDataURL","onDropOrPaste","transfer","getEventTransfer","isUrl","url","imageExtensions","find","endsWith","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_loop","_file$type$split3","_iterator","Symbol","iterator","done","err","return","renderBlockButton","icon","isActive","includes","onMouseDown","onClickBlock","firstBlock","grandParent","isList","isType","getClosest","react","this","components_FormatToolbar","name","id","disabled","slate_react_es","renderMark","onDrop","onPaste","Component","App","components_TextEditor","React","Boolean","location","hostname","match","ReactDOM","render","src_App_0","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.39df1305.chunk.js","sourcesContent":["import React from 'react'\nimport styled from 'react-emotion'\n\nexport const Button = styled('span')`\n  cursor: pointer;\n  color: ${props =>\n    props.reversed\n      ? props.active\n        ? 'white'\n        : '#aaa'\n      : props.active\n      ? 'black'\n      : '#ccc'};\n`\n\nexport const Icon = styled(({ className, ...rest }) => {\n  return <span className={`material-icons ${className}`} {...rest} />\n})`\n  font-size: 18px;\n  vertical-align: text-bottom;\n`\n\nexport const Menu = styled('div')`\n  & > * {\n    display: inline-block;\n  }\n\n  & > * + * {\n    margin-left: 15px;\n  }\n`\n\nexport const Toolbar = styled(Menu)`\n  position: relative;\n  padding: 1px 18px 17px;\n  margin: 0 -20px;\n  border-bottom: 2px solid #eee;\n  margin-bottom: 20px;\n`\n\nexport const Image = styled('img')`\n  display: block;\n  max-width: 100%;\n  max-height: 20em;\n  box-shadow: ${props => (props.selected ? '0 0 0 2px blue;' : 'none')};\n  margin: 5px;\n`\n","import React, { Component } from 'react'\n\nconst FormatToolbar = props => (\n  <div className=\"format-toolbar\">{props.children}</div>\n)\n\nexport default FormatToolbar\n","import React, { Component, Fragment } from 'react'\nimport { Editor, getEventRange, getEventTransfer } from 'slate-react'\nimport { Block, Value, Selection } from 'slate'\nimport imageExtensions from 'image-extensions'\nimport isUrl from 'is-url'\nimport { isKeyHotkey } from 'is-hotkey'\nimport { Button, Icon, Image } from './utils'\nimport FormatToolbar from './FormatToolbar'\nimport initialValueFromJSON from './value.json'\n\n/**\n * Define the default node type.\n *\n * @type {String}\n */\n\nconst DEFAULT_NODE = 'paragraph'\n\n/**\n * Define hotkey matchers.\n *\n * @type {Function}\n */\n\nconst isTabHotkey = isKeyHotkey('tab')\nconst isShiftTabHotkey = isKeyHotkey('shift+tab')\n\n// Update the initial content to be pulled from Local Storage if it exists.\nconst existingValue = JSON.parse(localStorage.getItem('content'))\n\nlet initialValue = Value.fromJSON(existingValue || initialValueFromJSON)\n\n// Schema\nconst schema = {\n  document: {\n    last: { type: 'paragraph' },\n    normalize: (editor, { code, node, child }) => {\n      switch (code) {\n        case 'last_child_type_invalid': {\n          const paragraph = Block.create('paragraph')\n          return editor.insertNodeByKey(node.key, node.nodes.size, paragraph)\n        }\n      }\n    }\n  },\n  blocks: {\n    image: {\n      isVoid: true\n    }\n  }\n}\n\n/**\n * Image extension check\n *\n * @param {String} url\n * @return {Boolean}\n */\nfunction isImage(url) {\n  return !!imageExtensions.find(url.endsWith)\n}\n\n/**\n * Insert an image into editor\n *\n * @param {Editor} editor\n * @param {String} src\n * @param {String} target\n */\n\nfunction insertImage(editor, src, target) {\n  if (target) {\n    editor.select(target)\n  }\n\n  editor.insertBlock({\n    type: 'image',\n    data: { src }\n  })\n}\n\nclass TextEditor extends Component {\n  state = {\n    value: initialValue,\n    saveButton: false,\n    blockLimit: 99999999,\n    fileSaved: false\n  }\n\n  /**\n   * Store a reference to the `editor`.\n   *\n   * @param {Editor} editor\n   */\n\n  ref = editor => {\n    this.editor = editor\n  }\n\n  /**\n   * Check if the any of the currently selected blocks are of `type`.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   */\n\n  hasBlock = type => {\n    const { value } = this.state\n    return value.blocks.some(node => node.type == type)\n  }\n\n  /**\n   * On change, save the new `value`.\n   *\n   * @param {Editor} editor\n   */\n\n  onChange = ({ value }) => {\n    // Check number of blocks and allowed blocks\n    if (this.countBlocks() > this.state.blockLimit) {\n      this.setState({ saveButton: true })\n    } else {\n      this.setState({ saveButton: false })\n    }\n\n    this.setState({ value })\n  }\n\n  /**\n   * When save button is clicked, save the current editor content.\n   *\n   * @param {Event} event\n   */\n\n  onClickSave = event => {\n    event.preventDefault()\n\n    // If save button is disabled, do not save\n    if (this.state.saveButton) return\n\n    const { editor } = this\n    const { value } = editor\n\n    // Save the value to Local Storage.\n    const content = JSON.stringify(value.toJSON())\n    localStorage.setItem('content', content)\n\n    // Update initialValue\n    initialValue = Value.fromJSON(JSON.parse(localStorage.getItem('content')))\n\n    this.setState({ value, fileSaved: true })\n\n    window.setTimeout(() => {\n      this.setState({ fileSaved: false })\n    }, 1000)\n  }\n\n  /**\n   * When cancel button is clicked, cancel current changes.\n   *\n   * @param {Event} event\n   */\n  onClickCancel = event => {\n    event.preventDefault()\n    this.setState({ value: initialValue })\n  }\n\n  /**\n   * Change block limit from dropdown.\n   *\n   * @param {Event} event\n   */\n  onChangeBlockLimit = event => {\n    event.preventDefault()\n\n    // Check number of blocks and allowed blocks\n    if (this.countBlocks() > event.target.value) {\n      this.setState({ saveButton: true, blockLimit: event.target.value })\n    } else {\n      this.setState({ saveButton: false, blockLimit: event.target.value })\n    }\n  }\n\n  // count blocks\n  countBlocks = () => {\n    const { editor } = this\n    const { value } = editor\n\n    const countBlocks = value.document.getBlocks().filter(block => {\n      if (block.type === 'paragraph') {\n        if (block.text === '') return false\n        else return block\n      } else return block\n    })\n\n    return countBlocks.size\n  }\n\n  /**\n   * On key down, if it's a formatting command toggle a mark.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @return {Change}\n   */\n\n  onKeyDown = (event, editor, next) => {\n    // tab\n    if (isTabHotkey(event)) {\n      const { value } = editor\n      const { document } = value\n\n      const block = value.blocks.first()\n      const parent = value.blocks.first()\n        ? document.getParent(value.blocks.first().key)\n        : null\n\n      // If no previous sibling exists, return\n      const previousSibling = document.getPreviousSibling(block.key)\n      if (!previousSibling) return next()\n\n      // check whether it's already in 3rd level\n      const depth = document.getDepth(block.key)\n      if (depth > 3) return next()\n\n      //check selected blocks, if any node is in 3rd level\n      let flag = false\n      value.blocks.map(block => {\n        let depth = document.getDepth(block.key)\n        if (depth > 3) flag = true\n      })\n      if (flag) return next()\n\n      // check previos sibling\n      if (\n        previousSibling &&\n        (previousSibling.type === 'numbered-list' ||\n          previousSibling.type === 'bulleted-list')\n      ) {\n        // todo\n        return next()\n      }\n\n      // check next sibling\n      const nextSibling = document.getNextSibling(block.key)\n      if (\n        nextSibling &&\n        (nextSibling.type === 'numbered-list' ||\n          nextSibling.type === 'bulleted-list')\n      ) {\n        // todo\n        return next()\n      }\n\n      if (parent) {\n        let type = !parent.type ? 'bulleted-list' : parent.type\n        editor.setBlocks('list-item').wrapBlock(type)\n      }\n    }\n    // shift + tab\n    else if (isShiftTabHotkey(event)) {\n      const { value } = editor\n      const { document } = value\n      const block = value.blocks.first()\n        ? document.getParent(value.blocks.first().key)\n        : null\n      let parent = document.getParent(block.key)\n\n      // if multi level list items are selected for shift+tab, then return\n      const firstBlockDepth =\n        value.blocks.first() && document.getDepth(value.blocks.first().key)\n      let hasChildren = false\n      value.blocks.map(blok => {\n        let depth = document.getDepth(blok.key)\n        if (firstBlockDepth !== depth) hasChildren = true\n      })\n      if (hasChildren) return next()\n\n      // if first level list-items selected then, make paragraph\n      if (parent && typeof parent.type === 'undefined') {\n        editor\n          .setBlocks(DEFAULT_NODE)\n          .unwrapBlock('bulleted-list')\n          .unwrapBlock('numbered-list')\n        return next()\n      }\n\n      const isActive =\n        this.hasBlock('list-item') &&\n        block &&\n        (block.type === 'numbered-list' || block.type === 'bulleted-list')\n\n      if (isActive) {\n        editor\n          .setBlocks('list-item')\n          .unwrapBlock('bulleted-list')\n          .unwrapBlock('numbered-list')\n      } else {\n        editor\n          .setBlocks(DEFAULT_NODE)\n          .unwrapBlock('bulleted-list')\n          .unwrapBlock('numbered-list')\n      }\n    } else {\n      return next()\n    }\n\n    event.preventDefault()\n  }\n\n  /**\n   * Render a Slate node.\n   *\n   * @param {Object} props\n   * @return {Element}\n   */\n\n  renderNode = (props, editor, next) => {\n    const { attributes, children, node, isFocused } = props\n\n    switch (node.type) {\n      case 'bulleted-list':\n        return <ul {...attributes}>{children}</ul>\n      case 'list-item':\n        return <li {...attributes}>{children}</li>\n      case 'numbered-list':\n        return <ol {...attributes}>{children}</ol>\n      case 'image': {\n        const src = node.data.get('src')\n        return <Image src={src} selected={isFocused} {...attributes} />\n      }\n      default:\n        return next()\n    }\n  }\n\n  /**\n   * When image button is clicked, save image from URL.\n   *\n   * @param {Event} event\n   */\n  onClickImage = event => {\n    event.preventDefault()\n    const src = window.prompt('Enter the URL of the image:')\n    if (!src) return\n    this.editor.command(insertImage, src)\n  }\n\n  /**\n   * When image upload button is clicked, open an expoler to upload image\n   *\n   * @param {Event} event\n   */\n  onClickImageUploadButton = event => {\n    event.preventDefault()\n    document.getElementById('image-file').click()\n  }\n\n  /**\n   * When image upload button is clicked, upload an image from machine's local storage.\n   *\n   * @param {Event} event\n   */\n  uploadImage = event => {\n    event.preventDefault()\n\n    const file = event.target.files[0]\n\n    const reader = new FileReader()\n\n    const [mime] = file.type.split('/')\n    if (mime !== 'image') return\n    const target = getEventRange(event, this.editor)\n    reader.addEventListener('load', () => {\n      this.editor.command(insertImage, reader.result, target)\n    })\n\n    const src = reader.readAsDataURL(file)\n    if (!src) return\n    this.editor.command(insertImage, src)\n  }\n\n  /**\n   * On drop, insert the image wherever it is dropped.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @return {Change}\n   */\n\n  onDropOrPaste = (event, editor, next) => {\n    const target = getEventRange(event, editor)\n    if (!target && event.type === 'drop') return next()\n\n    const transfer = getEventTransfer(event)\n    const { type, text, files } = transfer\n\n    if (type === 'files') {\n      for (const file of files) {\n        const reader = new FileReader()\n        const [mime] = file.type.split('/')\n        if (mime !== 'image') continue\n\n        reader.addEventListener('load', () => {\n          editor.command(insertImage, reader.result, target)\n        })\n\n        reader.readAsDataURL(file)\n      }\n      return\n    }\n\n    if (type === 'text') {\n      if (!isUrl(text)) return next()\n      if (!isImage(text)) return next()\n      editor.command(insertImage, text, target)\n      return\n    }\n\n    next()\n  }\n\n  /**\n   * Render a block-toggling toolbar button.\n   *\n   * @param {String} type\n   * @param {String} icon\n   * @return {Element}\n   */\n\n  renderBlockButton = (type, icon) => {\n    let isActive = this.hasBlock(type)\n\n    if (['numbered-list', 'bulleted-list'].includes(type)) {\n      const { value } = this.state\n      const parent = value.blocks.first()\n        ? value.document.getParent(value.blocks.first().key)\n        : null\n      isActive = this.hasBlock('list-item') && parent && parent.type === type\n    }\n\n    return (\n      <Button\n        active={isActive}\n        onMouseDown={event => this.onClickBlock(event, type)}\n      >\n        <Icon>{icon}</Icon>\n      </Button>\n    )\n  }\n\n  /**\n   * When a block button is clicked, toggle the block type.\n   *\n   * @param {Event} event\n   * @param {String} type\n   */\n\n  onClickBlock = (event, type) => {\n    event.preventDefault()\n\n    const { editor } = this\n    const { value } = editor\n    const { document } = value\n\n    // Handle everything but list buttons.\n    if (type != 'bulleted-list' && type != 'numbered-list') {\n      const isActive = this.hasBlock(type)\n      const isList = this.hasBlock('list-item')\n\n      if (isList) {\n        editor\n          .setBlocks(isActive ? DEFAULT_NODE : type)\n          .unwrapBlock('bulleted-list')\n          .unwrapBlock('numbered-list')\n      } else {\n        editor.setBlocks(isActive ? DEFAULT_NODE : type)\n      }\n    } else {\n      // if multi level list items are selected for shift+tab, then return\n      const firstBlockDepth =\n        value.blocks.first() && document.getDepth(value.blocks.first().key)\n      let hasChildren = false\n      value.blocks.map(blok => {\n        let depth = document.getDepth(blok.key)\n        if (firstBlockDepth !== depth) hasChildren = true\n      })\n      if (hasChildren) return\n\n      // check if parent is a list item\n      const firstBlock = value.blocks.first()\n      const parent = document.getParent(firstBlock.key)\n      const grandParent = document.getParent(parent.key)\n      if (grandParent && typeof grandParent.type !== 'undefined') {\n        return\n      }\n\n      // Handle the extra wrapping required for list buttons.\n      const isList = this.hasBlock('list-item')\n      const isType = value.blocks.some(block => {\n        return !!document.getClosest(block.key, parent => parent.type == type)\n      })\n\n      if (isList && isType) {\n        editor\n          .setBlocks(DEFAULT_NODE)\n          .unwrapBlock('bulleted-list')\n          .unwrapBlock('numbered-list')\n      } else if (isList) {\n        editor\n          .unwrapBlock(\n            type == 'bulleted-list' ? 'numbered-list' : 'bulleted-list'\n          )\n          .wrapBlock(type)\n      } else {\n        editor.setBlocks('list-item').wrapBlock(type)\n      }\n    }\n  }\n\n  render() {\n    return (\n      <Fragment>\n        <div>\n          <p>\n            <strong>{'Slate.js Demo'}</strong>\n            {this.state.fileSaved && <span>{' (File Saved!)'}</span>}\n          </p>\n        </div>\n        <FormatToolbar>\n          {this.renderBlockButton('numbered-list', 'format_list_numbered')}\n          {this.renderBlockButton('bulleted-list', 'format_list_bulleted')}\n          <Button onMouseDown={this.onClickImage}>\n            <Icon>{'image'}</Icon>\n          </Button>\n          <Button onMouseDown={this.onClickImageUploadButton}>\n            <Icon>{'image'}</Icon>\n          </Button>\n          <input\n            type=\"file\"\n            name=\"image\"\n            className=\"image-file\"\n            id=\"image-file\"\n            onChange={this.uploadImage}\n          />\n          &nbsp;\n          <select name=\"blockLimit\" onChange={this.onChangeBlockLimit}>\n            <option value={1}>1</option>\n            <option value={2}>2</option>\n            <option value={3}>3</option>\n            <option value={5}>5</option>\n            <option value={10}>10</option>\n            <option value={50}>50</option>\n            <option value={100}>100</option>\n            <option value={100}>100</option>\n            <option selected={true} value={99999999}>\n              Unlimited\n            </option>\n          </select>\n          <button\n            disabled={this.state.saveButton}\n            onMouseDown={this.onClickSave}\n          >\n            Save\n          </button>\n          <button onMouseDown={this.onClickCancel}>Cancel</button>\n        </FormatToolbar>\n\n        <Editor\n          ref={this.ref}\n          value={this.state.value}\n          schema={schema}\n          onChange={this.onChange}\n          onKeyDown={this.onKeyDown}\n          renderMark={this.renderMark}\n          renderNode={this.renderNode}\n          onDrop={this.onDropOrPaste}\n          onPaste={this.onDropOrPaste}\n        />\n      </Fragment>\n    )\n  }\n}\n\nexport default TextEditor\n","import React from 'react'\nimport TextEditor from './components/TextEditor'\nimport './App.css'\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <TextEditor />\n      </div>\n    )\n  }\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}